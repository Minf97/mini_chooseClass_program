{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nmodule.exports = fetch;\n\nvar asPromise = require(\"@protobufjs/aspromise\"),\n    inquire   = require(\"@protobufjs/inquire\");\n\nvar fs = inquire(\"fs\");\n\n/**\n * Node-style callback as used by {@link util.fetch}.\n * @typedef FetchCallback\n * @type {function}\n * @param {?Error} error Error, if any, otherwise `null`\n * @param {string} [contents] File contents, if there hasn't been an error\n * @returns {undefined}\n */\n\n/**\n * Options as used by {@link util.fetch}.\n * @typedef FetchOptions\n * @type {Object}\n * @property {boolean} [binary=false] Whether expecting a binary response\n * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest\n */\n\n/**\n * Fetches the contents of a file.\n * @memberof util\n * @param {string} filename File path or url\n * @param {FetchOptions} options Fetch options\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n */\nfunction fetch(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    } else if (!options)\n        options = {};\n\n    if (!callback)\n        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this\n\n    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.\n    if (!options.xhr && fs && fs.readFile)\n        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {\n            return err && typeof XMLHttpRequest !== \"undefined\"\n                ? fetch.xhr(filename, options, callback)\n                : err\n                ? callback(err)\n                : callback(null, options.binary ? contents : contents.toString(\"utf8\"));\n        });\n\n    // use the XHR version otherwise.\n    return fetch.xhr(filename, options, callback);\n}\n\n/**\n * Fetches the contents of a file.\n * @name util.fetch\n * @function\n * @param {string} path File path or url\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */\n\n/**\n * Fetches the contents of a file.\n * @name util.fetch\n * @function\n * @param {string} path File path or url\n * @param {FetchOptions} [options] Fetch options\n * @returns {Promise<string|Uint8Array>} Promise\n * @variation 3\n */\n\n/**/\nfetch.xhr = function fetch_xhr(filename, options, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {\n\n        if (xhr.readyState !== 4)\n            return undefined;\n\n        // local cors security errors return status 0 / empty string, too. afaik this cannot be\n        // reliably distinguished from an actually empty file for security reasons. feel free\n        // to send a pull request if you are aware of a solution.\n        if (xhr.status !== 0 && xhr.status !== 200)\n            return callback(Error(\"status \" + xhr.status));\n\n        // if binary data is expected, make sure that some sort of array is returned, even if\n        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.\n        if (options.binary) {\n            var buffer = xhr.response;\n            if (!buffer) {\n                buffer = [];\n                for (var i = 0; i < xhr.responseText.length; ++i)\n                    buffer.push(xhr.responseText.charCodeAt(i) & 255);\n            }\n            return callback(null, typeof Uint8Array !== \"undefined\" ? new Uint8Array(buffer) : buffer);\n        }\n        return callback(null, xhr.responseText);\n    };\n\n    if (options.binary) {\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers\n        if (\"overrideMimeType\" in xhr)\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n        xhr.responseType = \"arraybuffer\";\n    }\n\n    xhr.open(\"GET\", filename);\n    xhr.send();\n};\n"]}